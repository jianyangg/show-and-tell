<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Computer Use Runner</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        background: #0f172a;
        color: #e2e8f0;
      }

      body {
        margin: 0;
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 100vh;
        background: linear-gradient(160deg, #0f172a 0%, #111827 50%, #020617 100%);
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1.5rem;
        padding: 1.5rem 2rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(16px);
        background: rgba(15, 23, 42, 0.9);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      header .left {
        display: flex;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      header label {
        display: flex;
        flex-direction: column;
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.8);
        gap: 0.35rem;
      }

      header input,
      header select {
        min-width: 14rem;
        padding: 0.55rem 0.75rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.7);
        color: inherit;
      }

      header input:focus,
      header select:focus {
        outline: 2px solid rgba(96, 165, 250, 0.6);
        outline-offset: 2px;
      }

      header .controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        font-weight: 600;
        cursor: pointer;
        color: #021223;
        background: linear-gradient(135deg, #38bdf8, #0ea5e9);
        transition: transform 0.15s ease, box-shadow 0.2s ease, opacity 0.2s ease;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.4;
        box-shadow: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(14, 165, 233, 0.4);
      }

      .secondary-button {
        background: rgba(15, 23, 42, 0.8);
        color: rgba(226, 232, 240, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.4);
      }

      .secondary-button:not(:disabled):hover {
        box-shadow: 0 12px 18px rgba(148, 163, 184, 0.3);
      }

      main {
        display: grid;
        grid-template-columns: minmax(0, 2.5fr) minmax(0, 1fr);
        gap: 1.75rem;
        padding: 2rem;
      }

      .viewer {
        position: relative;
        background: rgba(15, 23, 42, 0.75);
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.45);
      }

      canvas {
        width: 100%;
        max-width: 100%;
        aspect-ratio: 16 / 10;
        background: radial-gradient(circle at 25% 25%, rgba(51, 65, 85, 0.4), rgba(15, 23, 42, 0.8));
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .status-line {
        font-size: 0.95rem;
        min-height: 1.5rem;
        color: rgba(148, 197, 255, 0.85);
      }

      .console-panel {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.6);
        padding: 0.85rem;
        max-height: 200px;
        overflow-y: auto;
      }

      .console-panel h2 {
        font-size: 0.9rem;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(148, 197, 255, 0.9);
      }

      .console-item {
        font-size: 0.8rem;
        line-height: 1.35;
        color: rgba(226, 232, 240, 0.85);
        white-space: pre-wrap;
        word-break: break-word;
      }

      .console-item strong {
        color: rgba(125, 211, 252, 0.95);
      }

      .events-panel {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.6);
        padding: 0.85rem;
        max-height: 240px;
        overflow-y: auto;
      }

      .events-panel h3 {
        font-size: 0.9rem;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(148, 197, 255, 0.9);
      }

      .event-log {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.75rem;
        line-height: 1.3;
        color: rgba(226, 232, 240, 0.85);
        white-space: pre-wrap;
        word-break: break-word;
      }

      .event-log .event-empty {
        opacity: 0.6;
      }

      .prompt {
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        background: rgba(15, 23, 42, 0.92);
        padding: 1rem;
        position: absolute;
        bottom: 1.5rem;
        left: 1.5rem;
        right: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.6);
      }

      .prompt.hidden {
        display: none;
      }

      .prompt p {
        margin: 0;
        font-size: 0.95rem;
        color: #f1f5f9;
      }

      .prompt-buttons {
        display: flex;
        gap: 0.75rem;
      }

      .prompt-buttons button:last-child {
        background: linear-gradient(135deg, #f87171, #ef4444);
        color: #1e293b;
      }

      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .sidebar section,
      .sidebar .recording,
      .sidebar .plan {
        padding: 1.25rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(148, 163, 184, 0.2);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      h2 {
        margin: 0;
        font-size: 1rem;
        letter-spacing: 0.02em;
      }

      .timeline {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 0.5rem;
      }

      .thumb {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(30, 41, 59, 0.8);
        color: inherit;
        font-size: 0.8rem;
        transition: transform 0.15s ease, border-color 0.15s ease;
      }

      .thumb:hover {
        transform: scale(1.02);
        border-color: rgba(96, 165, 250, 0.55);
      }

      #marker-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.8);
      }

      #plan-steps {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .plan-step {
        border-radius: 12px;
        padding: 0.85rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(30, 41, 59, 0.65);
        transition: border-color 0.15s ease, background 0.15s ease;
      }

      .plan-step.active {
        border-color: rgba(96, 165, 250, 0.7);
        background: rgba(30, 64, 175, 0.45);
      }

      .plan-step.done {
        border-color: rgba(74, 222, 128, 0.8);
        background: rgba(22, 101, 52, 0.35);
      }

      .plan-step h3 {
        margin: 0 0 0.4rem 0;
        font-size: 0.95rem;
      }

      .plan-step p {
        margin: 0;
        font-size: 0.8rem;
        color: rgba(226, 232, 240, 0.7);
        white-space: pre-wrap;
      }

      .plan-vars {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        padding: 0.6rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.55);
        margin-bottom: 0.75rem;
      }

      .plan-vars-title {
        margin: 0;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(148, 197, 255, 0.85);
      }

      .plan-vars-list {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        margin: 0;
        color: rgba(226, 232, 240, 0.78);
        font-size: 0.82rem;
      }

      .plan-var {
        display: flex;
        gap: 0.4rem;
        align-items: baseline;
        word-break: break-word;
      }

      .plan-var-name {
        font-weight: 600;
        color: rgba(148, 197, 255, 0.95);
      }

      .plan-var-value {
        color: rgba(226, 232, 240, 0.9);
      }

      .plan-vars-empty {
        font-size: 0.78rem;
        color: rgba(226, 232, 240, 0.6);
      }

      .plan-header {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 1rem;
      }

      .plan-name {
        font-size: 0.85rem;
        color: rgba(148, 197, 255, 0.85);
      }

      footer {
        text-align: center;
        padding: 1.5rem;
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.75);
        border-top: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.9);
      }

      @media (max-width: 1100px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      .modal.hidden {
        display: none;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }

      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(15, 23, 42, 0.65);
        backdrop-filter: blur(6px);
      }

      .modal-dialog {
        position: relative;
        background: rgba(2, 6, 23, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 16px;
        padding: 1.5rem;
        width: min(400px, 90vw);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.45);
      }

      .modal-dialog h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .modal-dialog p {
        margin: 0;
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.85);
      }

      .modal-dialog input {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.8);
        color: inherit;
      }

      .modal-dialog label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        color: rgba(226, 232, 240, 0.85);
      }

      .modal-dialog input:focus {
        outline: 2px solid rgba(96, 165, 250, 0.6);
        outline-offset: 2px;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }

      .modal-error {
        margin: 0;
        font-size: 0.78rem;
        color: rgba(248, 113, 113, 0.9);
      }
    </style>
  </head>
  <body>
    <header>
      <div class="left">
        <label>
          API Base
          <input id="api-base" type="text" placeholder="http://localhost:8000" />
        </label>
        <label>
          Start URL
          <input id="start-url" type="url" placeholder="https://example.com" />
        </label>
        <label>
          Plan Synthesizer
          <select id="synth-provider">
            <option value="gemini">Gemini 2.5 Pro</option>
            <option value="chatgpt">ChatGPT 5</option>
          </select>
        </label>
      </div>
      <div class="controls">
        <button id="start-record">Start Record</button>
        <button id="stop-record" disabled>Stop Record</button>
        <button id="synthesize" disabled>Synthesize Steps</button>
        <button id="run-steps" disabled>Run Steps</button>
        <button id="save-plan" class="secondary-button" disabled>Save Plan</button>
      </div>
    </header>
    <main>
      <section class="viewer" id="record-region">
        <canvas id="viewer-canvas" width="960" height="600"></canvas>
        <div class="status-line" id="status-line">Idle.</div>
        <div class="console-panel" id="console-panel">
          <h2>Console</h2>
          <div id="console-log"></div>
        </div>
        <div class="prompt hidden" id="safety-prompt">
          <p id="prompt-text"></p>
          <div class="prompt-buttons">
            <button id="prompt-allow">Allow</button>
            <button id="prompt-deny">Deny</button>
          </div>
        </div>
      </section>
      <aside class="sidebar">
        <div class="recording">
          <h2>Recording Review</h2>
          <div class="timeline" id="timeline"></div>
          <ul id="marker-list"></ul>
          <div class="events-panel">
            <h3>Events</h3>
            <div class="event-log" id="event-log">
              <div class="event-empty">No events yet.</div>
            </div>
          </div>
        </div>
        <div class="plan">
          <div class="plan-header">
            <h2>Plan Steps</h2>
            <span id="plan-name-label" class="plan-name">No plan loaded</span>
          </div>
          <div id="plan-vars-wrap"></div>
          <ul id="plan-steps">
            <li class="plan-step">
              <h3>No plan loaded</h3>
              <p>Record and synthesize to view steps.</p>
            </li>
          </ul>
        </div>
      </aside>
    </main>
    <footer>
      Mark a step with <strong>⌘M</strong> / <strong>Ctrl+M</strong> while recording to drop a timeline marker.
    </footer>
    <div id="save-modal" class="modal hidden" aria-hidden="true">
      <div class="modal-backdrop" id="save-modal-backdrop"></div>
      <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="save-modal-title">
        <h2 id="save-modal-title">Name this plan</h2>
        <p>Pick a descriptive title so you can find this sequence later.</p>
        <input id="save-plan-name" type="text" placeholder="e.g. Checkout flow" />
        <div class="modal-actions">
          <button id="save-modal-cancel" class="secondary-button" type="button">Cancel</button>
          <button id="save-modal-confirm" type="button">Save</button>
        </div>
      </div>
    </div>
    <div id="variables-modal" class="modal hidden" aria-hidden="true">
      <div class="modal-backdrop" id="variables-modal-backdrop"></div>
      <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="variables-modal-title">
        <h2 id="variables-modal-title">Plan variables required</h2>
        <p id="variables-modal-description">Provide values so the run can continue.</p>
        <form id="variables-form">
          <div id="variables-fields"></div>
          <p id="variables-error" class="modal-error" style="display: none;"></p>
          <div class="modal-actions">
            <button id="variables-cancel" class="secondary-button" type="button">Abort Run</button>
            <button id="variables-submit" type="submit">Continue</button>
          </div>
        </form>
      </div>
    </div>
    <script>
      (() => {
        const apiBaseInput = document.getElementById('api-base');
        const startUrlInput = document.getElementById('start-url');
        const synthProviderSelect = document.getElementById('synth-provider');
        const startRecordBtn = document.getElementById('start-record');
        const stopRecordBtn = document.getElementById('stop-record');
        const synthesizeBtn = document.getElementById('synthesize');
        const runBtn = document.getElementById('run-steps');
        const savePlanBtn = document.getElementById('save-plan');
        const statusLine = document.getElementById('status-line');
        const viewerCanvas = document.getElementById('viewer-canvas');
        const viewerCtx = viewerCanvas.getContext('2d');
        const timelineEl = document.getElementById('timeline');
        const markerListEl = document.getElementById('marker-list');
        const planStepsEl = document.getElementById('plan-steps');
        const planNameLabel = document.getElementById('plan-name-label');
        const planVarsWrap = document.getElementById('plan-vars-wrap');
        const promptEl = document.getElementById('safety-prompt');
        const promptTextEl = document.getElementById('prompt-text');
        const promptAllowBtn = document.getElementById('prompt-allow');
        const promptDenyBtn = document.getElementById('prompt-deny');
        const consolePanel = document.getElementById('console-panel');
        const consoleLog = document.getElementById('console-log');
        const eventLogEl = document.getElementById('event-log');
        const saveModal = document.getElementById('save-modal');
        const saveModalBackdrop = document.getElementById('save-modal-backdrop');
        const saveModalInput = document.getElementById('save-plan-name');
        const saveModalConfirm = document.getElementById('save-modal-confirm');
        const saveModalCancel = document.getElementById('save-modal-cancel');
        const variablesModal = document.getElementById('variables-modal');
        const variablesBackdrop = document.getElementById('variables-modal-backdrop');
        const variablesForm = document.getElementById('variables-form');
        const variablesFields = document.getElementById('variables-fields');
        const variablesSubmit = document.getElementById('variables-submit');
        const variablesCancel = document.getElementById('variables-cancel');
        const variablesError = document.getElementById('variables-error');
        const PROVIDER_LABELS = {
          // gemini: 'Gemini 2.5 Pro', // not working well
          chatgpt: 'ChatGPT 5',
        };
        const PROVIDER_STORAGE_KEY = 'plan-synth-provider';
        const DEFAULT_PLAN_NAME = 'Unnamed plan';
        function normalizeStartUrl(raw) {
          if (!raw) return null;
          const trimmed = String(raw).trim();
          if (!trimmed) return null;
          return /^[a-zA-Z][a-zA-Z\d+\-.]*:\/\//.test(trimmed) ? trimmed : `http://${trimmed}`;
        }
        try {
          const savedProvider = localStorage.getItem(PROVIDER_STORAGE_KEY);
          if (savedProvider && Object.prototype.hasOwnProperty.call(PROVIDER_LABELS, savedProvider)) {
            synthProviderSelect.value = savedProvider;
          }
        } catch (err) {
          console.warn('Unable to load provider preference from storage', err);
        }
        synthProviderSelect.addEventListener('change', () => {
          try {
            localStorage.setItem(PROVIDER_STORAGE_KEY, synthProviderSelect.value);
          } catch (err) {
            console.warn('Unable to persist provider preference', err);
          }
        });

        function setPlanName(name) {
          if (planNameLabel) {
            planNameLabel.textContent = name ? name : 'No plan loaded';
          }
        }

        let recordingFrames = [];
        let recordingMarkers = [];
        let recordingStartedAt = 0;
        let latestRecordingDetail = null;
        let planDetail = null;
        let planStepMap = new Map();
        const variableInputs = new Map();
        let pendingVariableNames = [];
        let runSocket = null;
        let latestRunId = null;
        let pendingPromptPayload = null;

        function openSaveModal() {
          if (!planDetail) return;
          saveModal.classList.remove('hidden');
          saveModal.setAttribute('aria-hidden', 'false');
          saveModalConfirm.disabled = false;
          saveModalInput.value = planDetail.plan?.name || '';
          setTimeout(() => saveModalInput.focus(), 0);
        }

        function closeSaveModal() {
          saveModal.classList.add('hidden');
          saveModal.setAttribute('aria-hidden', 'true');
        }

        // --- Teach Mode (remote Playwright) ---
        let teachSocket = null;
        let detachTeach = null;
        let teachViewport = { width: 1440, height: 900 }; // must match backend

        function buildTeachWsUrl(teachId) {
          const u = new URL(apiBase());
          u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
          u.pathname = u.pathname.replace(/\/$/, '') + `/ws/teach/${encodeURIComponent(teachId)}`;
          return u.toString();
        }

        function canvasXYToViewport(e) {
          const r = viewerCanvas.getBoundingClientRect();
          const x = ((e.clientX - r.left) / r.width) * teachViewport.width;
          const y = ((e.clientY - r.top) / r.height) * teachViewport.height;
          return {
            x: Math.max(0, Math.min(teachViewport.width, x)),
            y: Math.max(0, Math.min(teachViewport.height, y)),
          };
        }

        function attachTeachListeners() {
          viewerCanvas.tabIndex = 0; // allow key events
          function send(type, payload = {}) {
            if (teachSocket && teachSocket.readyState === 1) {
              teachSocket.send(JSON.stringify({ type, ...payload }));
            }
          }
          const isMarkerHotkey = (e) => e.key.toLowerCase() === 'm' && (e.metaKey || e.ctrlKey);
          const onMouseDown = (e) => {
            const { x, y } = canvasXYToViewport(e);
            send('mouse_down', { x, y, button: e.button });
            e.preventDefault();
          };
          const onMouseUp = (e) => {
            const { x, y } = canvasXYToViewport(e);
            send('mouse_up', { x, y, button: e.button });
            e.preventDefault();
          };
          const onMouseMove = (e) => {
            const { x, y } = canvasXYToViewport(e);
            send('mouse_move', { x, y });
          };
          const onWheel = (e) => {
            const { x, y } = canvasXYToViewport(e);
            send('wheel', { x, y, deltaX: e.deltaX, deltaY: e.deltaY });
            e.preventDefault();
          };
          const onKeyDown = (e) => {
            if (isMarkerHotkey(e)) return;
            send('key_down', {
              key: e.key,
              code: e.code,
              alt: e.altKey,
              ctrl: e.ctrlKey,
              meta: e.metaKey,
              shift: e.shiftKey,
            });
            e.preventDefault();
          };
          const onKeyUp = (e) => {
            if (isMarkerHotkey(e)) return;
            send('key_up', {
              key: e.key,
              code: e.code,
              alt: e.altKey,
              ctrl: e.ctrlKey,
              meta: e.metaKey,
              shift: e.shiftKey,
            });
            e.preventDefault();
          };

          viewerCanvas.addEventListener('mousedown', onMouseDown);
          window.addEventListener('mouseup', onMouseUp);
          viewerCanvas.addEventListener('mousemove', onMouseMove);
          viewerCanvas.addEventListener('wheel', onWheel, { passive: false });
          viewerCanvas.addEventListener('keydown', onKeyDown);
          viewerCanvas.addEventListener('keyup', onKeyUp);

          return () => {
            viewerCanvas.removeEventListener('mousedown', onMouseDown);
            window.removeEventListener('mouseup', onMouseUp);
            viewerCanvas.removeEventListener('mousemove', onMouseMove);
            viewerCanvas.removeEventListener('wheel', onWheel, { passive: false });
            viewerCanvas.removeEventListener('keydown', onKeyDown);
            viewerCanvas.removeEventListener('keyup', onKeyUp);
          };
        }

        apiBaseInput.value = window.location.origin;

        function apiBase() {
          let v = (apiBaseInput.value || '').trim() || window.location.origin;
          if (!/^https?:\/\//i.test(v)) {
            v = `http://${v}`;
          }
          return v.replace(/\/$/, '');
        }

        function setStatus(message) {
          statusLine.textContent = message;
        }

        function appendConsole(role, message) {
          if (!consoleLog) {
            return;
          }
          const entry = document.createElement('div');
          entry.className = 'console-item';
          const label = document.createElement('strong');
          label.textContent = `[${role}] `;
          entry.appendChild(label);
          entry.appendChild(document.createTextNode(message));
          consoleLog.appendChild(entry);
          if (consolePanel) {
            consolePanel.scrollTop = consolePanel.scrollHeight;
          }
        }

        function clearConsole() {
          if (consoleLog) {
            consoleLog.innerHTML = '';
          }
        }

        function formatVariableDisplay(value) {
          if (value === null || value === undefined) {
            return '(pending)';
          }
          if (typeof value === 'string') {
            const trimmed = value.trim();
            return trimmed ? trimmed : '(pending)';
          }
          return String(value);
        }

        function renderPlanVars(planData) {
          if (!planVarsWrap) {
            return;
          }
          planVarsWrap.innerHTML = '';
          if (!planData) {
            return;
          }
          const hasVarsFlag = Boolean(planData.hasVariables);
          const entries = Object.entries(planData.vars || {});
          if (!entries.length && !hasVarsFlag) {
            return;
          }
          const container = document.createElement('div');
          container.className = 'plan-vars';
          const title = document.createElement('p');
          title.className = 'plan-vars-title';
          title.textContent = 'Variables';
          container.appendChild(title);
          if (entries.length) {
            const list = document.createElement('div');
            list.className = 'plan-vars-list';
            entries
              .slice()
              .sort((a, b) => a[0].localeCompare(b[0]))
              .forEach(([name, value]) => {
                const item = document.createElement('div');
                item.className = 'plan-var';
                const nameEl = document.createElement('span');
                nameEl.className = 'plan-var-name';
                nameEl.textContent = name;
                const valueEl = document.createElement('span');
                valueEl.className = 'plan-var-value';
                valueEl.textContent = formatVariableDisplay(value);
                item.appendChild(nameEl);
                item.appendChild(valueEl);
                list.appendChild(item);
              });
            container.appendChild(list);
          } else {
            const empty = document.createElement('div');
            empty.className = 'plan-vars-empty';
            empty.textContent = 'Values will be requested before running.';
            container.appendChild(empty);
          }
          planVarsWrap.appendChild(container);
        }

        function resetPlanView() {
          planDetail = null;
          planStepMap.clear();
          planStepsEl.innerHTML = '';
          const placeholder = document.createElement('li');
          placeholder.className = 'plan-step';
          placeholder.innerHTML = '<h3>No plan loaded</h3><p>Record and synthesize to view steps.</p>';
          planStepsEl.appendChild(placeholder);
          runBtn.disabled = true;
          savePlanBtn.disabled = true;
          setPlanName('No plan loaded');
          renderPlanVars(null);
          closeVariablesModal();
        }

        function renderPlan(planData) {
          planStepMap.clear();
          planStepsEl.innerHTML = '';
          setPlanName(planData.name || DEFAULT_PLAN_NAME);
          renderPlanVars(planData);
          planData.steps.forEach((step) => {
            const li = document.createElement('li');
            li.className = 'plan-step';
            const title = document.createElement('h3');
            title.textContent = `${step.id}: ${step.title}`;
            const body = document.createElement('p');
            body.textContent = step.instructions || '(no instructions provided)';
            li.appendChild(title);
            li.appendChild(body);
            planStepsEl.appendChild(li);
            planStepMap.set(step.id, li);
          });
          savePlanBtn.disabled = false;
        }

        function highlightStep(stepId) {
          planStepMap.forEach((li) => li.classList.remove('active'));
          const target = planStepMap.get(stepId);
          if (target) {
            target.classList.remove('done');
            target.classList.add('active');
          }
        }

        function markStepDone(stepId) {
          const target = planStepMap.get(stepId);
          if (target) {
            target.classList.remove('active');
            target.classList.add('done');
          }
        }

        function closeVariablesModal() {
          if (!variablesModal) {
            return;
          }
          pendingVariableNames = [];
          variableInputs.clear();
          if (variablesFields) {
            variablesFields.innerHTML = '';
          }
          if (variablesError) {
            variablesError.textContent = '';
            variablesError.style.display = 'none';
          }
          if (variablesSubmit) {
            variablesSubmit.disabled = false;
          }
          variablesModal.classList.add('hidden');
        }

        function openVariablesModal(payload) {
          if (!variablesModal || !variablesFields) {
            return;
          }
          variableInputs.clear();
          pendingVariableNames = [];
          variablesFields.innerHTML = '';
          if (variablesError) {
            variablesError.textContent = '';
            variablesError.style.display = 'none';
          }
          const inputs = Array.isArray(payload?.vars) ? payload.vars : [];
          inputs.forEach((entry) => {
            const name = typeof entry?.name === 'string' ? entry.name.trim() : '';
            if (!name) {
              return;
            }
            pendingVariableNames.push(name);
            const wrapper = document.createElement('label');
            wrapper.textContent = name;
            const input = document.createElement('input');
            input.type = 'text';
            input.name = name;
            input.dataset.varName = name;
            const value = entry?.value;
            if (value === null || value === undefined) {
              input.value = '';
            } else if (typeof value === 'string') {
              input.value = value;
            } else {
              input.value = String(value);
            }
            input.required = true;
            wrapper.appendChild(input);
            variablesFields.appendChild(wrapper);
            variableInputs.set(name, input);
          });
          if (!pendingVariableNames.length) {
            setStatus('Runner requested variables but none were provided.');
            return;
          }
          if (variablesSubmit) {
            variablesSubmit.disabled = false;
          }
          variablesModal.classList.remove('hidden');
          setStatus('Awaiting variable inputs…');
          window.setTimeout(() => {
            const firstName = pendingVariableNames[0];
            const firstInput = variableInputs.get(firstName);
            if (firstInput) {
              firstInput.focus();
              firstInput.select();
            }
          }, 0);
        }

        function abortRunFromVariables() {
          if (runSocket) {
            runSocket.send(JSON.stringify({ type: 'abort' }));
          }
          appendConsole('Runner', 'Abort requested while waiting for variables.');
          setStatus('Abort requested.');
          closeVariablesModal();
        }

        function renderTimeline() {
          timelineEl.innerHTML = '';
          if (!recordingFrames.length) {
            const empty = document.createElement('div');
            empty.className = 'thumb';
            empty.textContent = 'No frames yet';
            empty.disabled = true;
            timelineEl.appendChild(empty);
            return;
          }
          recordingFrames.forEach((frame, index) => {
            const button = document.createElement('button');
            button.className = 'thumb';
            button.type = 'button';
            button.textContent = `${index + 1} • ${frame.timestamp.toFixed(1)}s`;
            button.addEventListener('click', () => drawFrame(frame.png));
            timelineEl.appendChild(button);
          });
        }

        function renderMarkers() {
          markerListEl.innerHTML = '';
          if (!recordingMarkers.length) {
            const li = document.createElement('li');
            li.textContent = 'No markers yet.';
            markerListEl.appendChild(li);
            return;
          }
          recordingMarkers.forEach((marker, index) => {
            const li = document.createElement('li');
            const label = marker.label || `Marker ${index + 1}`;
            li.textContent = `${marker.timestamp.toFixed(1)}s • ${label}`;
            markerListEl.appendChild(li);
          });
        }

        function renderEvents(events) {
          if (!eventLogEl) {
            return;
          }
          eventLogEl.innerHTML = '';
          if (!events.length) {
            const empty = document.createElement('div');
            empty.className = 'event-empty';
            empty.textContent = 'No events yet.';
            eventLogEl.appendChild(empty);
            return;
          }
          const recent = events.slice(-50);
          recent.forEach((event) => {
            const item = document.createElement('div');
            item.className = 'event-item';
            const ts = typeof event.ts === 'number' ? `${event.ts.toFixed(3)}s` : String(event.ts || '?');
            const kind = event.kind || 'event';
            let detail = '';
            if (kind === 'input') {
              detail = `→ ${event.selector || ''} len=${event.len ?? '?'}`;
            } else if (kind === 'click' || kind === 'pointerdown') {
              const labelSource = (event.actionable && (event.actionable.label || event.actionable.tag)) || (event.element && event.element.label);
              const buttonLabel = event.button ? ` ${event.button}` : '';
              detail = `→ (${Number(event.x).toFixed(1)}, ${Number(event.y).toFixed(1)})${labelSource ? ` "${labelSource}"` : ''}${event.selector ? ` ${event.selector}` : ''}${buttonLabel}`;
            } else if (kind && kind.startsWith('tab_')) {
              detail = `→ ${event.title || ''}`;
            } else if (kind === 'key_hold') {
              const duration = typeof event.duration === 'number' ? `${event.duration.toFixed(2)}s` : String(event.duration || '?');
              const combo = event.combo || event.key || '?';
              detail = `→ ${combo} for ${duration}`;
            } else if (kind === 'keydown_repeat') {
              detail = `→ ${event.combo || event.key || '?'}`;
            } else if (kind === 'keydown' || kind === 'keyup') {
              const combo = event.combo || event.key || '?';
              detail = `→ ${combo}`;
            } else if (event.key) {
              detail = `→ ${event.key}`;
            }
            item.textContent = `${ts} ${kind}${detail ? ` ${detail}` : ''}`;
            eventLogEl.appendChild(item);
          });
        }

        function drawFrame(base64Png, cursor) {
          const image = new Image();
          image.onload = () => {
            viewerCtx.clearRect(0, 0, viewerCanvas.width, viewerCanvas.height);
            const scale = Math.min(
              viewerCanvas.width / image.width,
              viewerCanvas.height / image.height
            );
            const drawWidth = image.width * scale;
            const drawHeight = image.height * scale;
            const offsetX = (viewerCanvas.width - drawWidth) / 2;
            const offsetY = (viewerCanvas.height - drawHeight) / 2;
            viewerCtx.drawImage(image, offsetX, offsetY, drawWidth, drawHeight);

            if (cursor && typeof cursor.x === 'number' && typeof cursor.y === 'number') {
              const x = offsetX + drawWidth * cursor.x;
              const y = offsetY + drawHeight * cursor.y;
              viewerCtx.save();
              viewerCtx.beginPath();
              viewerCtx.strokeStyle = '#38bdf8';
              viewerCtx.lineWidth = 2;
              viewerCtx.arc(x, y, 12, 0, Math.PI * 2);
              viewerCtx.stroke();
              viewerCtx.fillStyle = 'rgba(56, 189, 248, 0.35)';
              viewerCtx.fill();
              viewerCtx.restore();
            }
          };
          image.src = `data:image/png;base64,${base64Png}`;
        }

        function markerHotkeyListener(event) {
          if (event.key.toLowerCase() === 'm' && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            const timestamp = (performance.now() - recordingStartedAt) / 1000;
            const marker = {
              timestamp: Number(timestamp.toFixed(3)),
              label: `Marker ${recordingMarkers.length + 1}`,
            };
            recordingMarkers.push(marker);
            renderMarkers();
            setStatus(`Marked ${marker.label}`);
          }
        }

        async function startRecording() {
          resetPlanView();
          clearConsole();
          setStatus('Starting teach session…');
          try {
            const startUrlPayload = normalizeStartUrl(startUrlInput.value);
            const res = await fetch(`${apiBase()}/teach/start`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ startUrl: startUrlPayload }),
            });
            if (!res.ok) throw new Error(await res.text());
            const { teachId, viewport, recordingId } = await res.json();
            if (viewport?.width && viewport?.height) teachViewport = viewport;
            if (recordingId) {
              appendConsole('Teach', `Recording id ${recordingId}`);
            }

            // Open WS to stream frames and send inputs
            teachSocket = new WebSocket(buildTeachWsUrl(teachId));
            detachTeach = attachTeachListeners();

            teachSocket.addEventListener('open', () => {
              setStatus(`Teaching… (${teachId})`);
              appendConsole('Teach', `Connected to ${teachId}`);
              viewerCanvas.focus();
            });

            teachSocket.addEventListener('message', (ev) => {
              const msg = JSON.parse(ev.data);
              if (msg.type === 'runner_frame') {
                // msg.frame/msg.png: base64 png, msg.cursor: {x:0..1,y:0..1}
                drawFrame(msg.frame || msg.png, msg.cursor);
              } else if (msg.type === 'event_log') {
                renderEvents(msg.events || []);
              } else if (msg.type === 'status') {
                setStatus(msg.message);
              }
            });

            teachSocket.addEventListener('close', () => {
              setStatus('Teach session closed.');
              if (detachTeach) {
                detachTeach();
                detachTeach = null;
              }
              teachSocket = null;
            });

            // initialise timeline UI
            recordingFrames = [];
            recordingMarkers = [];
            recordingStartedAt = performance.now();
            window.addEventListener('keydown', markerHotkeyListener);
            renderMarkers();
            renderTimeline();
            renderEvents([]);

            startRecordBtn.disabled = true;
            stopRecordBtn.disabled = false;
            synthesizeBtn.disabled = true;
          } catch (e) {
            if (detachTeach) {
              detachTeach();
              detachTeach = null;
            }
            if (teachSocket) {
              teachSocket.close();
              teachSocket = null;
            }
            window.removeEventListener('keydown', markerHotkeyListener);
            setStatus(`Failed to start teach session: ${e instanceof Error ? e.message : e}`);
            appendConsole('Teach', `Failed: ${e}`);
          }
        }

        async function stopRecording() {
          setStatus('Stopping teach session…');
          try {
            if (teachSocket) {
              teachSocket.close();
              teachSocket = null;
            }
            if (detachTeach) {
              detachTeach();
              detachTeach = null;
            }
            window.removeEventListener('keydown', markerHotkeyListener);

            const res = await fetch(`${apiBase()}/teach/stop`, { method: 'POST' });
            if (!res.ok) throw new Error(await res.text());
            latestRecordingDetail = await res.json(); // { recordingId, frames, markers, events }
            recordingFrames = latestRecordingDetail.frames || [];
            const serverMarkers = latestRecordingDetail.markers || [];
            if (!recordingMarkers.length && serverMarkers.length) {
              recordingMarkers = serverMarkers;
            }
            renderMarkers();
            renderTimeline();
            setStatus(
              `Recording ${latestRecordingDetail.recordingId} saved (${(latestRecordingDetail.frames || []).length} frames).`
            );
            appendConsole('Teach', `Recording ${latestRecordingDetail.recordingId} saved.`);
            renderEvents(latestRecordingDetail.events || []);
            synthesizeBtn.disabled = false;
          } catch (e) {
            setStatus(`Failed to stop: ${e instanceof Error ? e.message : e}`);
          } finally {
            startRecordBtn.disabled = false;
            stopRecordBtn.disabled = true;
          }
        }

        async function synthesizePlan() {
          if (!latestRecordingDetail) {
            setStatus('Capture a recording before synthesizing.');
            return;
          }
          const provider = synthProviderSelect.value;
          const providerName = PROVIDER_LABELS[provider] || provider;
          setStatus(`Requesting plan synthesis via ${providerName}…`);
          synthesizeBtn.disabled = true;
          appendConsole('Synthesizer', `Sending bundle to ${providerName}…`);
          try {
            const response = await fetch(`${apiBase()}/plans/synthesize`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                recordingId: latestRecordingDetail.recordingId,
                planName: 'Captured flow',
                provider,
                startUrl: normalizeStartUrl(startUrlInput.value),
              }),
            });
            if (!response.ok) {
              throw new Error(await response.text());
            }
            planDetail = await response.json();
            if (planDetail?.plan && !planDetail.plan.name) {
              planDetail.plan.name = DEFAULT_PLAN_NAME;
            }
            if (planDetail?.plan) {
              startUrlInput.value =
                typeof planDetail.plan.startUrl === 'string' ? planDetail.plan.startUrl : '';
            }
            renderPlan(planDetail.plan);
            const hasVars = Boolean(planDetail.hasVariables || planDetail.plan?.hasVariables);
            const statusMessage = hasVars
              ? `Plan ${planDetail.planId} ready. Variables will be requested before running.`
              : `Plan ${planDetail.planId} ready. Review steps before running.`;
            setStatus(statusMessage);
            runBtn.disabled = false;
            synthesizeBtn.disabled = false;
            appendConsole('Synthesizer', `Plan provider: ${providerName}`);
            if (hasVars) {
              const varNames = Object.keys(planDetail.plan?.vars || {});
              appendConsole(
                'Synthesizer',
                varNames.length
                  ? `Plan variables detected: ${varNames.join(', ')}`
                  : 'Plan includes unresolved variables.'
              );
            }
            if (planDetail.prompt) {
              appendConsole('Synthesizer prompt', planDetail.prompt);
              console.info('Plan synthesis prompt:\n', planDetail.prompt);
            }
            if (planDetail.rawResponse) {
              appendConsole('Synthesizer response', planDetail.rawResponse);
              console.info('Plan synthesis raw response:\n', planDetail.rawResponse);
            }
          } catch (error) {
            console.error('Plan synthesis failed', error);
            const message = error instanceof Error ? error.message : String(error);
            setStatus(`Plan synthesis failed (${providerName}): ${message}`);
            appendConsole('Synthesizer', `Failed (${providerName}): ${message}`);
            synthesizeBtn.disabled = false;
          }
        }

        function closeRunSocket() {
          if (runSocket) {
            runSocket.close();
            runSocket = null;
          }
          closeVariablesModal();
        }

        function buildWsUrl(runId) {
          const u = new URL(apiBase());
          u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
          u.pathname = u.pathname.replace(/\/$/, '') + `/ws/runs/${encodeURIComponent(runId)}`;
          u.search = '';
          return u.toString();
        }

        function showPrompt(payload) {
          pendingPromptPayload = payload;
          const summary = `${payload.action || 'action'} ${JSON.stringify(payload.args || {})}`;
          promptTextEl.textContent = `Allow model-proposed ${summary}?`;
          promptEl.classList.remove('hidden');
        }

        function hidePrompt() {
          pendingPromptPayload = null;
          promptEl.classList.add('hidden');
        }

        function connectToRun(runId) {
          closeRunSocket();
          const wsUrl = buildWsUrl(runId);
          runSocket = new WebSocket(wsUrl);
          runSocket.addEventListener('open', () => {
            setStatus(`Connected to run ${runId}.`);
            appendConsole('Runner', `Connected to ${wsUrl}`);
          });
          runSocket.addEventListener('message', (event) => {
            try {
              const message = JSON.parse(event.data);
              handleRunMessage(message);
            } catch (error) {
              console.error('Malformed runner message', error);
            }
          });
          runSocket.addEventListener('close', () => {
            setStatus('Run connection closed.');
            runSocket = null;
            hidePrompt();
            closeVariablesModal();
            appendConsole('Runner', 'Connection closed.');
            runBtn.disabled = false;
          });
          runSocket.addEventListener('error', () => {
            setStatus('Run connection error.');
            appendConsole('Runner', 'Connection error.');
            closeVariablesModal();
            runBtn.disabled = false;
          });
        }

        function handleRunMessage(message) {
          switch (message.type) {
            case 'runner_frame':
              drawFrame(message.frame || message.png, message.cursor);
              break;
            case 'runner_status':
              setStatus(message.message || 'Runner update');
              {
                const statusLabel = message.message || 'status update';
                const detail = message.error || message.reason;
                appendConsole('Runner', detail ? `${statusLabel}: ${detail}` : statusLabel);
              }
              if (['failed', 'aborted', 'completed'].includes(message.message)) {
                runBtn.disabled = false;
                closeVariablesModal();
              }
              if (message.message === 'failed' || message.message === 'aborted' || message.message === 'completed') {
                hidePrompt();
              }
              break;
            case 'step_started':
              highlightStep(message.stepId);
              appendConsole('Runner', `Step started: ${message.stepId}`);
              break;
            case 'step_completed':
              markStepDone(message.stepId);
              appendConsole('Runner', `Step completed: ${message.stepId}`);
              break;
            case 'run_completed':
              setStatus(message.ok ? 'Run completed successfully.' : 'Run finished.');
              hidePrompt();
              closeVariablesModal();
              appendConsole('Runner', message.ok ? 'Run completed successfully.' : 'Run finished.');
              runBtn.disabled = false;
              break;
            case 'safety_prompt':
              showPrompt(message.payload || {});
              appendConsole('Runner', 'Safety confirmation required.');
              break;
            case 'variable_prompt':
              openVariablesModal(message.payload || {});
              appendConsole('Runner', 'Awaiting operator-provided variables.');
              break;
            case 'variables_applied': {
              closeVariablesModal();
              const applied = message.vars && typeof message.vars === 'object' ? message.vars : {};
              if (planDetail?.plan) {
                planDetail.plan.vars = {
                  ...(planDetail.plan.vars || {}),
                  ...applied,
                };
                renderPlanVars(planDetail.plan);
              }
              const parts = Object.entries(applied || {}).map(([name, value]) => `${name}=${formatVariableDisplay(value)}`);
              appendConsole('Runner', parts.length ? `Variables applied: ${parts.join(', ')}` : 'Variables applied.');
              break;
            }
            case 'console': {
              const role = message.role || 'Log';
              const content = message.message || '';
              appendConsole(role, content);
              if (role === 'ComputerUse prompt') {
                console.info('Computer Use prompt:\n', content);
              }
              break;
            }
            default:
              break;
          }
        }

        async function runPlan() {
          if (!planDetail) {
            setStatus('Generate a plan first.');
            return;
          }
          hidePrompt();
          closeVariablesModal();
          planStepMap.forEach((li) => li.classList.remove('done', 'active'));
          appendConsole('Runner', `Launching plan ${planDetail.planId}`);

          const payload = {
            planId: planDetail.planId,
            startUrl: normalizeStartUrl(startUrlInput.value),
          };
          setStatus('Starting run…');
          runBtn.disabled = true;
          try {
            const response = await fetch(`${apiBase()}/runs/start`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            if (!response.ok) {
              throw new Error(await response.text());
            }
            const data = await response.json();
            latestRunId = data.runId;
            connectToRun(latestRunId);
            setStatus(`Run ${latestRunId} launched.`);
            appendConsole('Runner', `Run ${latestRunId} launched.`);
          } catch (error) {
            console.error('Run start failed', error);
            setStatus(`Run failed to start: ${error instanceof Error ? error.message : error}`);
            appendConsole('Runner', `Run failed to start: ${error instanceof Error ? error.message : String(error)}`);
            runBtn.disabled = false;
          }
        }

        savePlanBtn.addEventListener('click', () => {
          if (!planDetail) {
            setStatus('Generate a plan before saving.');
            return;
          }
          openSaveModal();
        });

        const handleSaveConfirm = async () => {
          if (!planDetail) return;
          const name = saveModalInput.value.trim();
          if (!name) {
            saveModalInput.focus();
            setStatus('Enter a plan name before saving.');
            return;
          }
          saveModalConfirm.disabled = true;
          try {
            const response = await fetch(`${apiBase()}/plans/${planDetail.planId}/save`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name,
                plan: planDetail.plan || null,
              }),
            });
            if (!response.ok) {
              throw new Error(await response.text());
            }
            const data = await response.json();
            if (planDetail) {
              planDetail.plan = data.plan;
              setPlanName(data.name || DEFAULT_PLAN_NAME);
              renderPlan(planDetail.plan);
            }
            appendConsole('Synthesizer', `Plan saved as "${data.name}".`);
            setStatus(`Plan saved as "${data.name}".`);
            closeSaveModal();
          } catch (error) {
            console.error('Plan save failed', error);
            const message = error instanceof Error ? error.message : String(error);
            setStatus(`Plan save failed: ${message}`);
          } finally {
            saveModalConfirm.disabled = false;
          }
        };

        saveModalConfirm.addEventListener('click', handleSaveConfirm);
        saveModalCancel.addEventListener('click', closeSaveModal);
        saveModalBackdrop.addEventListener('click', closeSaveModal);
        saveModalInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            handleSaveConfirm();
          }
        });

        if (variablesForm) {
          variablesForm.addEventListener('submit', (event) => {
            event.preventDefault();
            if (!runSocket) {
              setStatus('No active run to receive variables.');
              appendConsole('Runner', 'Unable to submit variables: no active run.');
              closeVariablesModal();
              return;
            }
            if (!pendingVariableNames.length) {
              closeVariablesModal();
              return;
            }
            if (variablesSubmit) {
              variablesSubmit.disabled = true;
            }
            const values = {};
            const missing = [];
            pendingVariableNames.forEach((name) => {
              const input = variableInputs.get(name);
              if (!input) {
                missing.push(name);
                return;
              }
              const raw = input.value;
              if (!raw || !raw.trim()) {
                missing.push(name);
                input.focus();
                input.select();
                return;
              }
              values[name] = raw.trim();
            });
            if (missing.length) {
              if (variablesError) {
                variablesError.textContent = `Please provide values for: ${missing.join(', ')}`;
                variablesError.style.display = 'block';
              }
              if (variablesSubmit) {
                variablesSubmit.disabled = false;
              }
              return;
            }
            if (variablesError) {
              variablesError.textContent = '';
              variablesError.style.display = 'none';
            }
            runSocket.send(JSON.stringify({ type: 'submit_variables', values }));
            appendConsole('Runner', 'Submitted variable values.');
            setStatus('Variables submitted. Resuming run…');
            closeVariablesModal();
          });
        }

        if (variablesCancel) {
          variablesCancel.addEventListener('click', () => {
            abortRunFromVariables();
          });
        }

        if (variablesBackdrop) {
          variablesBackdrop.addEventListener('click', () => {
            abortRunFromVariables();
          });
        }

        window.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            if (variablesModal && !variablesModal.classList.contains('hidden')) {
              event.preventDefault();
              abortRunFromVariables();
              return;
            }
            if (!saveModal.classList.contains('hidden')) {
              closeSaveModal();
            }
          }
        });

        startRecordBtn.addEventListener('click', () => {
          startRecording().catch((error) => {
            console.error('Recording failed', error);
            setStatus(`Recording failed: ${error instanceof Error ? error.message : error}`);
          });
        });
        stopRecordBtn.addEventListener('click', () => {
          stopRecording().catch((error) => {
            console.error('Stop recording failed', error);
            setStatus(`Stop recording failed: ${error instanceof Error ? error.message : error}`);
          });
        });
        synthesizeBtn.addEventListener('click', () => {
          synthesizePlan().catch((error) => {
            console.error('Synthesis failed', error);
            setStatus(`Synthesis failed: ${error instanceof Error ? error.message : error}`);
          });
        });
        runBtn.addEventListener('click', () => {
          runPlan().catch((error) => {
            console.error('Run failed', error);
            setStatus(`Run failed: ${error instanceof Error ? error.message : error}`);
            runBtn.disabled = false;
          });
        });

        promptAllowBtn.addEventListener('click', () => {
          if (runSocket) {
            runSocket.send(JSON.stringify({ type: 'confirm_action', allow: true }));
          }
          hidePrompt();
        });
        promptDenyBtn.addEventListener('click', () => {
          if (runSocket) {
            runSocket.send(JSON.stringify({ type: 'confirm_action', allow: false }));
          }
          hidePrompt();
        });

        window.addEventListener('beforeunload', () => {
          if (teachSocket) {
            teachSocket.close();
            teachSocket = null;
          }
          if (detachTeach) {
            detachTeach();
            detachTeach = null;
          }
          window.removeEventListener('keydown', markerHotkeyListener);
          closeRunSocket();
        });

        setStatus('Ready to record.');
        renderTimeline();
        renderMarkers();
      })();
    </script>
  </body>
</html>
